# DP 실버

# 3 또는 2로 나누어 떨어지면 나눌 수 있고 아니면 -1을 할 수 있다.
n=int(input())
d=[0]*(n+1)
# d에는 인덱스 i를 1로 만들기 위한 최소 연산횟수가 저장된다.
for i in range(2, n+1):
    d[i]=d[i-1]+1
    # i-1을 계산하기 위한 최소 연산횟수에 1을 더한다 (-1을 하는 경우 때문에)

    if i%2==0: # 2로 나누어 떨어질 경우 ex 8이면 8을 2로 나눴을 경우 +1을 해주고, 8/2=4이기 때문에 d[4](즉, 4를 1로 만드는 최소 연산 횟수)를 더해준다.
        d[i] = min(d[i], d[i//2]+1)
    
    if i%3==0: # 3도 마찬가지이다.
        d[i]=min(d[i], d[i//3]+1)
            

print(d[n])